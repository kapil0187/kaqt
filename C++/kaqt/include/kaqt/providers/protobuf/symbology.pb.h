// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: symbology.proto

#ifndef PROTOBUF_symbology_2eproto__INCLUDED
#define PROTOBUF_symbology_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace kaqt {
namespace providers {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_symbology_2eproto();
void protobuf_AssignDesc_symbology_2eproto();
void protobuf_ShutdownFile_symbology_2eproto();

class FuturesInstrumentRequest;
class FuturesInstrumentResponse;
class FuturesInstrument;
class AlternateId;
class Instrument;
class FutureSpecification;
class OptionSpecification;
class ForexSpecification;

enum FuturesInstrumentRequest_RequestType {
  FuturesInstrumentRequest_RequestType_ALL = 0,
  FuturesInstrumentRequest_RequestType_UNDERLYING = 1,
  FuturesInstrumentRequest_RequestType_EXCHANGE = 2
};
bool FuturesInstrumentRequest_RequestType_IsValid(int value);
const FuturesInstrumentRequest_RequestType FuturesInstrumentRequest_RequestType_RequestType_MIN = FuturesInstrumentRequest_RequestType_ALL;
const FuturesInstrumentRequest_RequestType FuturesInstrumentRequest_RequestType_RequestType_MAX = FuturesInstrumentRequest_RequestType_EXCHANGE;
const int FuturesInstrumentRequest_RequestType_RequestType_ARRAYSIZE = FuturesInstrumentRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FuturesInstrumentRequest_RequestType_descriptor();
inline const ::std::string& FuturesInstrumentRequest_RequestType_Name(FuturesInstrumentRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FuturesInstrumentRequest_RequestType_descriptor(), value);
}
inline bool FuturesInstrumentRequest_RequestType_Parse(
    const ::std::string& name, FuturesInstrumentRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FuturesInstrumentRequest_RequestType>(
    FuturesInstrumentRequest_RequestType_descriptor(), name, value);
}
enum Instrument_InstrumentType {
  Instrument_InstrumentType_STOCK = 0,
  Instrument_InstrumentType_FUTURE = 1,
  Instrument_InstrumentType_OPTION = 2,
  Instrument_InstrumentType_FOREX = 3
};
bool Instrument_InstrumentType_IsValid(int value);
const Instrument_InstrumentType Instrument_InstrumentType_InstrumentType_MIN = Instrument_InstrumentType_STOCK;
const Instrument_InstrumentType Instrument_InstrumentType_InstrumentType_MAX = Instrument_InstrumentType_FOREX;
const int Instrument_InstrumentType_InstrumentType_ARRAYSIZE = Instrument_InstrumentType_InstrumentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Instrument_InstrumentType_descriptor();
inline const ::std::string& Instrument_InstrumentType_Name(Instrument_InstrumentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Instrument_InstrumentType_descriptor(), value);
}
inline bool Instrument_InstrumentType_Parse(
    const ::std::string& name, Instrument_InstrumentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Instrument_InstrumentType>(
    Instrument_InstrumentType_descriptor(), name, value);
}
// ===================================================================

class FuturesInstrumentRequest : public ::google::protobuf::Message {
 public:
  FuturesInstrumentRequest();
  virtual ~FuturesInstrumentRequest();

  FuturesInstrumentRequest(const FuturesInstrumentRequest& from);

  inline FuturesInstrumentRequest& operator=(const FuturesInstrumentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FuturesInstrumentRequest& default_instance();

  void Swap(FuturesInstrumentRequest* other);

  // implements Message ----------------------------------------------

  FuturesInstrumentRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FuturesInstrumentRequest& from);
  void MergeFrom(const FuturesInstrumentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FuturesInstrumentRequest_RequestType RequestType;
  static const RequestType ALL = FuturesInstrumentRequest_RequestType_ALL;
  static const RequestType UNDERLYING = FuturesInstrumentRequest_RequestType_UNDERLYING;
  static const RequestType EXCHANGE = FuturesInstrumentRequest_RequestType_EXCHANGE;
  static inline bool RequestType_IsValid(int value) {
    return FuturesInstrumentRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    FuturesInstrumentRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    FuturesInstrumentRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    FuturesInstrumentRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return FuturesInstrumentRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return FuturesInstrumentRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return FuturesInstrumentRequest_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .kaqt.providers.protobuf.FuturesInstrumentRequest.RequestType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::kaqt::providers::protobuf::FuturesInstrumentRequest_RequestType type() const;
  inline void set_type(::kaqt::providers::protobuf::FuturesInstrumentRequest_RequestType value);

  // optional string underlying = 2;
  inline bool has_underlying() const;
  inline void clear_underlying();
  static const int kUnderlyingFieldNumber = 2;
  inline const ::std::string& underlying() const;
  inline void set_underlying(const ::std::string& value);
  inline void set_underlying(const char* value);
  inline void set_underlying(const char* value, size_t size);
  inline ::std::string* mutable_underlying();
  inline ::std::string* release_underlying();
  inline void set_allocated_underlying(::std::string* underlying);

  // optional string exchange = 3;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // @@protoc_insertion_point(class_scope:kaqt.providers.protobuf.FuturesInstrumentRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_underlying();
  inline void clear_has_underlying();
  inline void set_has_exchange();
  inline void clear_has_exchange();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* underlying_;
  ::std::string* exchange_;
  int type_;
  friend void  protobuf_AddDesc_symbology_2eproto();
  friend void protobuf_AssignDesc_symbology_2eproto();
  friend void protobuf_ShutdownFile_symbology_2eproto();

  void InitAsDefaultInstance();
  static FuturesInstrumentRequest* default_instance_;
};
// -------------------------------------------------------------------

class FuturesInstrumentResponse : public ::google::protobuf::Message {
 public:
  FuturesInstrumentResponse();
  virtual ~FuturesInstrumentResponse();

  FuturesInstrumentResponse(const FuturesInstrumentResponse& from);

  inline FuturesInstrumentResponse& operator=(const FuturesInstrumentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FuturesInstrumentResponse& default_instance();

  void Swap(FuturesInstrumentResponse* other);

  // implements Message ----------------------------------------------

  FuturesInstrumentResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FuturesInstrumentResponse& from);
  void MergeFrom(const FuturesInstrumentResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kaqt.providers.protobuf.FuturesInstrument instruments = 1;
  inline int instruments_size() const;
  inline void clear_instruments();
  static const int kInstrumentsFieldNumber = 1;
  inline const ::kaqt::providers::protobuf::FuturesInstrument& instruments(int index) const;
  inline ::kaqt::providers::protobuf::FuturesInstrument* mutable_instruments(int index);
  inline ::kaqt::providers::protobuf::FuturesInstrument* add_instruments();
  inline const ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::FuturesInstrument >&
      instruments() const;
  inline ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::FuturesInstrument >*
      mutable_instruments();

  // @@protoc_insertion_point(class_scope:kaqt.providers.protobuf.FuturesInstrumentResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::FuturesInstrument > instruments_;
  friend void  protobuf_AddDesc_symbology_2eproto();
  friend void protobuf_AssignDesc_symbology_2eproto();
  friend void protobuf_ShutdownFile_symbology_2eproto();

  void InitAsDefaultInstance();
  static FuturesInstrumentResponse* default_instance_;
};
// -------------------------------------------------------------------

class FuturesInstrument : public ::google::protobuf::Message {
 public:
  FuturesInstrument();
  virtual ~FuturesInstrument();

  FuturesInstrument(const FuturesInstrument& from);

  inline FuturesInstrument& operator=(const FuturesInstrument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FuturesInstrument& default_instance();

  void Swap(FuturesInstrument* other);

  // implements Message ----------------------------------------------

  FuturesInstrument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FuturesInstrument& from);
  void MergeFrom(const FuturesInstrument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string ticker = 2;
  inline bool has_ticker() const;
  inline void clear_ticker();
  static const int kTickerFieldNumber = 2;
  inline const ::std::string& ticker() const;
  inline void set_ticker(const ::std::string& value);
  inline void set_ticker(const char* value);
  inline void set_ticker(const char* value, size_t size);
  inline ::std::string* mutable_ticker();
  inline ::std::string* release_ticker();
  inline void set_allocated_ticker(::std::string* ticker);

  // optional string underlying = 3;
  inline bool has_underlying() const;
  inline void clear_underlying();
  static const int kUnderlyingFieldNumber = 3;
  inline const ::std::string& underlying() const;
  inline void set_underlying(const ::std::string& value);
  inline void set_underlying(const char* value);
  inline void set_underlying(const char* value, size_t size);
  inline ::std::string* mutable_underlying();
  inline ::std::string* release_underlying();
  inline void set_allocated_underlying(::std::string* underlying);

  // required string description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // required string exchange_group = 5;
  inline bool has_exchange_group() const;
  inline void clear_exchange_group();
  static const int kExchangeGroupFieldNumber = 5;
  inline const ::std::string& exchange_group() const;
  inline void set_exchange_group(const ::std::string& value);
  inline void set_exchange_group(const char* value);
  inline void set_exchange_group(const char* value, size_t size);
  inline ::std::string* mutable_exchange_group();
  inline ::std::string* release_exchange_group();
  inline void set_allocated_exchange_group(::std::string* exchange_group);

  // required string exchange = 6;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 6;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // required int64 expiry_posix_datetime = 7;
  inline bool has_expiry_posix_datetime() const;
  inline void clear_expiry_posix_datetime();
  static const int kExpiryPosixDatetimeFieldNumber = 7;
  inline ::google::protobuf::int64 expiry_posix_datetime() const;
  inline void set_expiry_posix_datetime(::google::protobuf::int64 value);

  // required int32 min_order_size = 8;
  inline bool has_min_order_size() const;
  inline void clear_min_order_size();
  static const int kMinOrderSizeFieldNumber = 8;
  inline ::google::protobuf::int32 min_order_size() const;
  inline void set_min_order_size(::google::protobuf::int32 value);

  // required double tick_size = 9;
  inline bool has_tick_size() const;
  inline void clear_tick_size();
  static const int kTickSizeFieldNumber = 9;
  inline double tick_size() const;
  inline void set_tick_size(double value);

  // required double tradeable_tick_size = 10;
  inline bool has_tradeable_tick_size() const;
  inline void clear_tradeable_tick_size();
  static const int kTradeableTickSizeFieldNumber = 10;
  inline double tradeable_tick_size() const;
  inline void set_tradeable_tick_size(double value);

  // required string currency = 11;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 11;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // repeated .kaqt.providers.protobuf.AlternateId alternate_id = 12;
  inline int alternate_id_size() const;
  inline void clear_alternate_id();
  static const int kAlternateIdFieldNumber = 12;
  inline const ::kaqt::providers::protobuf::AlternateId& alternate_id(int index) const;
  inline ::kaqt::providers::protobuf::AlternateId* mutable_alternate_id(int index);
  inline ::kaqt::providers::protobuf::AlternateId* add_alternate_id();
  inline const ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId >&
      alternate_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId >*
      mutable_alternate_id();

  // repeated int32 constituents_ids = 13;
  inline int constituents_ids_size() const;
  inline void clear_constituents_ids();
  static const int kConstituentsIdsFieldNumber = 13;
  inline ::google::protobuf::int32 constituents_ids(int index) const;
  inline void set_constituents_ids(int index, ::google::protobuf::int32 value);
  inline void add_constituents_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      constituents_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_constituents_ids();

  // repeated int32 constituents_ratios = 14;
  inline int constituents_ratios_size() const;
  inline void clear_constituents_ratios();
  static const int kConstituentsRatiosFieldNumber = 14;
  inline ::google::protobuf::int32 constituents_ratios(int index) const;
  inline void set_constituents_ratios(int index, ::google::protobuf::int32 value);
  inline void add_constituents_ratios(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      constituents_ratios() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_constituents_ratios();

  // @@protoc_insertion_point(class_scope:kaqt.providers.protobuf.FuturesInstrument)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ticker();
  inline void clear_has_ticker();
  inline void set_has_underlying();
  inline void clear_has_underlying();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_exchange_group();
  inline void clear_has_exchange_group();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_expiry_posix_datetime();
  inline void clear_has_expiry_posix_datetime();
  inline void set_has_min_order_size();
  inline void clear_has_min_order_size();
  inline void set_has_tick_size();
  inline void clear_has_tick_size();
  inline void set_has_tradeable_tick_size();
  inline void clear_has_tradeable_tick_size();
  inline void set_has_currency();
  inline void clear_has_currency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ticker_;
  ::std::string* underlying_;
  ::std::string* description_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 min_order_size_;
  ::std::string* exchange_group_;
  ::std::string* exchange_;
  ::google::protobuf::int64 expiry_posix_datetime_;
  double tick_size_;
  double tradeable_tick_size_;
  ::std::string* currency_;
  ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId > alternate_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > constituents_ids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > constituents_ratios_;
  friend void  protobuf_AddDesc_symbology_2eproto();
  friend void protobuf_AssignDesc_symbology_2eproto();
  friend void protobuf_ShutdownFile_symbology_2eproto();

  void InitAsDefaultInstance();
  static FuturesInstrument* default_instance_;
};
// -------------------------------------------------------------------

class AlternateId : public ::google::protobuf::Message {
 public:
  AlternateId();
  virtual ~AlternateId();

  AlternateId(const AlternateId& from);

  inline AlternateId& operator=(const AlternateId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlternateId& default_instance();

  void Swap(AlternateId* other);

  // implements Message ----------------------------------------------

  AlternateId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlternateId& from);
  void MergeFrom(const AlternateId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id_type = 1;
  inline bool has_id_type() const;
  inline void clear_id_type();
  static const int kIdTypeFieldNumber = 1;
  inline const ::std::string& id_type() const;
  inline void set_id_type(const ::std::string& value);
  inline void set_id_type(const char* value);
  inline void set_id_type(const char* value, size_t size);
  inline ::std::string* mutable_id_type();
  inline ::std::string* release_id_type();
  inline void set_allocated_id_type(::std::string* id_type);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:kaqt.providers.protobuf.AlternateId)
 private:
  inline void set_has_id_type();
  inline void clear_has_id_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_type_;
  ::std::string* id_;
  ::std::string* description_;
  friend void  protobuf_AddDesc_symbology_2eproto();
  friend void protobuf_AssignDesc_symbology_2eproto();
  friend void protobuf_ShutdownFile_symbology_2eproto();

  void InitAsDefaultInstance();
  static AlternateId* default_instance_;
};
// -------------------------------------------------------------------

class Instrument : public ::google::protobuf::Message {
 public:
  Instrument();
  virtual ~Instrument();

  Instrument(const Instrument& from);

  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Instrument& default_instance();

  void Swap(Instrument* other);

  // implements Message ----------------------------------------------

  Instrument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Instrument& from);
  void MergeFrom(const Instrument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Instrument_InstrumentType InstrumentType;
  static const InstrumentType STOCK = Instrument_InstrumentType_STOCK;
  static const InstrumentType FUTURE = Instrument_InstrumentType_FUTURE;
  static const InstrumentType OPTION = Instrument_InstrumentType_OPTION;
  static const InstrumentType FOREX = Instrument_InstrumentType_FOREX;
  static inline bool InstrumentType_IsValid(int value) {
    return Instrument_InstrumentType_IsValid(value);
  }
  static const InstrumentType InstrumentType_MIN =
    Instrument_InstrumentType_InstrumentType_MIN;
  static const InstrumentType InstrumentType_MAX =
    Instrument_InstrumentType_InstrumentType_MAX;
  static const int InstrumentType_ARRAYSIZE =
    Instrument_InstrumentType_InstrumentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InstrumentType_descriptor() {
    return Instrument_InstrumentType_descriptor();
  }
  static inline const ::std::string& InstrumentType_Name(InstrumentType value) {
    return Instrument_InstrumentType_Name(value);
  }
  static inline bool InstrumentType_Parse(const ::std::string& name,
      InstrumentType* value) {
    return Instrument_InstrumentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required .kaqt.providers.protobuf.Instrument.InstrumentType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::kaqt::providers::protobuf::Instrument_InstrumentType type() const;
  inline void set_type(::kaqt::providers::protobuf::Instrument_InstrumentType value);

  // required string ticker = 3;
  inline bool has_ticker() const;
  inline void clear_ticker();
  static const int kTickerFieldNumber = 3;
  inline const ::std::string& ticker() const;
  inline void set_ticker(const ::std::string& value);
  inline void set_ticker(const char* value);
  inline void set_ticker(const char* value, size_t size);
  inline ::std::string* mutable_ticker();
  inline ::std::string* release_ticker();
  inline void set_allocated_ticker(::std::string* ticker);

  // required string description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // required string exchange = 5;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 5;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional string exchange_group = 6;
  inline bool has_exchange_group() const;
  inline void clear_exchange_group();
  static const int kExchangeGroupFieldNumber = 6;
  inline const ::std::string& exchange_group() const;
  inline void set_exchange_group(const ::std::string& value);
  inline void set_exchange_group(const char* value);
  inline void set_exchange_group(const char* value, size_t size);
  inline ::std::string* mutable_exchange_group();
  inline ::std::string* release_exchange_group();
  inline void set_allocated_exchange_group(::std::string* exchange_group);

  // required int32 min_order_size = 7;
  inline bool has_min_order_size() const;
  inline void clear_min_order_size();
  static const int kMinOrderSizeFieldNumber = 7;
  inline ::google::protobuf::int32 min_order_size() const;
  inline void set_min_order_size(::google::protobuf::int32 value);

  // required double tick_size = 8;
  inline bool has_tick_size() const;
  inline void clear_tick_size();
  static const int kTickSizeFieldNumber = 8;
  inline double tick_size() const;
  inline void set_tick_size(double value);

  // required double tradeable_tick_size = 9;
  inline bool has_tradeable_tick_size() const;
  inline void clear_tradeable_tick_size();
  static const int kTradeableTickSizeFieldNumber = 9;
  inline double tradeable_tick_size() const;
  inline void set_tradeable_tick_size(double value);

  // required string currency = 10;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 10;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // repeated .kaqt.providers.protobuf.AlternateId alternate_id = 11;
  inline int alternate_id_size() const;
  inline void clear_alternate_id();
  static const int kAlternateIdFieldNumber = 11;
  inline const ::kaqt::providers::protobuf::AlternateId& alternate_id(int index) const;
  inline ::kaqt::providers::protobuf::AlternateId* mutable_alternate_id(int index);
  inline ::kaqt::providers::protobuf::AlternateId* add_alternate_id();
  inline const ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId >&
      alternate_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId >*
      mutable_alternate_id();

  // optional .kaqt.providers.protobuf.FutureSpecification futures_spec = 12;
  inline bool has_futures_spec() const;
  inline void clear_futures_spec();
  static const int kFuturesSpecFieldNumber = 12;
  inline const ::kaqt::providers::protobuf::FutureSpecification& futures_spec() const;
  inline ::kaqt::providers::protobuf::FutureSpecification* mutable_futures_spec();
  inline ::kaqt::providers::protobuf::FutureSpecification* release_futures_spec();
  inline void set_allocated_futures_spec(::kaqt::providers::protobuf::FutureSpecification* futures_spec);

  // optional .kaqt.providers.protobuf.OptionSpecification options_spec = 13;
  inline bool has_options_spec() const;
  inline void clear_options_spec();
  static const int kOptionsSpecFieldNumber = 13;
  inline const ::kaqt::providers::protobuf::OptionSpecification& options_spec() const;
  inline ::kaqt::providers::protobuf::OptionSpecification* mutable_options_spec();
  inline ::kaqt::providers::protobuf::OptionSpecification* release_options_spec();
  inline void set_allocated_options_spec(::kaqt::providers::protobuf::OptionSpecification* options_spec);

  // @@protoc_insertion_point(class_scope:kaqt.providers.protobuf.Instrument)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ticker();
  inline void clear_has_ticker();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_exchange_group();
  inline void clear_has_exchange_group();
  inline void set_has_min_order_size();
  inline void clear_has_min_order_size();
  inline void set_has_tick_size();
  inline void clear_has_tick_size();
  inline void set_has_tradeable_tick_size();
  inline void clear_has_tradeable_tick_size();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_futures_spec();
  inline void clear_has_futures_spec();
  inline void set_has_options_spec();
  inline void clear_has_options_spec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  int type_;
  ::std::string* ticker_;
  ::std::string* description_;
  ::std::string* exchange_;
  ::std::string* exchange_group_;
  double tick_size_;
  double tradeable_tick_size_;
  ::std::string* currency_;
  ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId > alternate_id_;
  ::kaqt::providers::protobuf::FutureSpecification* futures_spec_;
  ::kaqt::providers::protobuf::OptionSpecification* options_spec_;
  ::google::protobuf::int32 min_order_size_;
  friend void  protobuf_AddDesc_symbology_2eproto();
  friend void protobuf_AssignDesc_symbology_2eproto();
  friend void protobuf_ShutdownFile_symbology_2eproto();

  void InitAsDefaultInstance();
  static Instrument* default_instance_;
};
// -------------------------------------------------------------------

class FutureSpecification : public ::google::protobuf::Message {
 public:
  FutureSpecification();
  virtual ~FutureSpecification();

  FutureSpecification(const FutureSpecification& from);

  inline FutureSpecification& operator=(const FutureSpecification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FutureSpecification& default_instance();

  void Swap(FutureSpecification* other);

  // implements Message ----------------------------------------------

  FutureSpecification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FutureSpecification& from);
  void MergeFrom(const FutureSpecification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 expiry_posix_datetime = 1;
  inline bool has_expiry_posix_datetime() const;
  inline void clear_expiry_posix_datetime();
  static const int kExpiryPosixDatetimeFieldNumber = 1;
  inline ::google::protobuf::int64 expiry_posix_datetime() const;
  inline void set_expiry_posix_datetime(::google::protobuf::int64 value);

  // required string underlying = 2;
  inline bool has_underlying() const;
  inline void clear_underlying();
  static const int kUnderlyingFieldNumber = 2;
  inline const ::std::string& underlying() const;
  inline void set_underlying(const ::std::string& value);
  inline void set_underlying(const char* value);
  inline void set_underlying(const char* value, size_t size);
  inline ::std::string* mutable_underlying();
  inline ::std::string* release_underlying();
  inline void set_allocated_underlying(::std::string* underlying);

  // @@protoc_insertion_point(class_scope:kaqt.providers.protobuf.FutureSpecification)
 private:
  inline void set_has_expiry_posix_datetime();
  inline void clear_has_expiry_posix_datetime();
  inline void set_has_underlying();
  inline void clear_has_underlying();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 expiry_posix_datetime_;
  ::std::string* underlying_;
  friend void  protobuf_AddDesc_symbology_2eproto();
  friend void protobuf_AssignDesc_symbology_2eproto();
  friend void protobuf_ShutdownFile_symbology_2eproto();

  void InitAsDefaultInstance();
  static FutureSpecification* default_instance_;
};
// -------------------------------------------------------------------

class OptionSpecification : public ::google::protobuf::Message {
 public:
  OptionSpecification();
  virtual ~OptionSpecification();

  OptionSpecification(const OptionSpecification& from);

  inline OptionSpecification& operator=(const OptionSpecification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionSpecification& default_instance();

  void Swap(OptionSpecification* other);

  // implements Message ----------------------------------------------

  OptionSpecification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OptionSpecification& from);
  void MergeFrom(const OptionSpecification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double strike = 1;
  inline bool has_strike() const;
  inline void clear_strike();
  static const int kStrikeFieldNumber = 1;
  inline double strike() const;
  inline void set_strike(double value);

  // required int64 expiry_posix_datetime = 2;
  inline bool has_expiry_posix_datetime() const;
  inline void clear_expiry_posix_datetime();
  static const int kExpiryPosixDatetimeFieldNumber = 2;
  inline ::google::protobuf::int64 expiry_posix_datetime() const;
  inline void set_expiry_posix_datetime(::google::protobuf::int64 value);

  // required string underlying = 3;
  inline bool has_underlying() const;
  inline void clear_underlying();
  static const int kUnderlyingFieldNumber = 3;
  inline const ::std::string& underlying() const;
  inline void set_underlying(const ::std::string& value);
  inline void set_underlying(const char* value);
  inline void set_underlying(const char* value, size_t size);
  inline ::std::string* mutable_underlying();
  inline ::std::string* release_underlying();
  inline void set_allocated_underlying(::std::string* underlying);

  // @@protoc_insertion_point(class_scope:kaqt.providers.protobuf.OptionSpecification)
 private:
  inline void set_has_strike();
  inline void clear_has_strike();
  inline void set_has_expiry_posix_datetime();
  inline void clear_has_expiry_posix_datetime();
  inline void set_has_underlying();
  inline void clear_has_underlying();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double strike_;
  ::google::protobuf::int64 expiry_posix_datetime_;
  ::std::string* underlying_;
  friend void  protobuf_AddDesc_symbology_2eproto();
  friend void protobuf_AssignDesc_symbology_2eproto();
  friend void protobuf_ShutdownFile_symbology_2eproto();

  void InitAsDefaultInstance();
  static OptionSpecification* default_instance_;
};
// -------------------------------------------------------------------

class ForexSpecification : public ::google::protobuf::Message {
 public:
  ForexSpecification();
  virtual ~ForexSpecification();

  ForexSpecification(const ForexSpecification& from);

  inline ForexSpecification& operator=(const ForexSpecification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ForexSpecification& default_instance();

  void Swap(ForexSpecification* other);

  // implements Message ----------------------------------------------

  ForexSpecification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForexSpecification& from);
  void MergeFrom(const ForexSpecification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string counter_currency = 1;
  inline bool has_counter_currency() const;
  inline void clear_counter_currency();
  static const int kCounterCurrencyFieldNumber = 1;
  inline const ::std::string& counter_currency() const;
  inline void set_counter_currency(const ::std::string& value);
  inline void set_counter_currency(const char* value);
  inline void set_counter_currency(const char* value, size_t size);
  inline ::std::string* mutable_counter_currency();
  inline ::std::string* release_counter_currency();
  inline void set_allocated_counter_currency(::std::string* counter_currency);

  // @@protoc_insertion_point(class_scope:kaqt.providers.protobuf.ForexSpecification)
 private:
  inline void set_has_counter_currency();
  inline void clear_has_counter_currency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* counter_currency_;
  friend void  protobuf_AddDesc_symbology_2eproto();
  friend void protobuf_AssignDesc_symbology_2eproto();
  friend void protobuf_ShutdownFile_symbology_2eproto();

  void InitAsDefaultInstance();
  static ForexSpecification* default_instance_;
};
// ===================================================================


// ===================================================================

// FuturesInstrumentRequest

// required .kaqt.providers.protobuf.FuturesInstrumentRequest.RequestType type = 1;
inline bool FuturesInstrumentRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FuturesInstrumentRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FuturesInstrumentRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FuturesInstrumentRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::kaqt::providers::protobuf::FuturesInstrumentRequest_RequestType FuturesInstrumentRequest::type() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrumentRequest.type)
  return static_cast< ::kaqt::providers::protobuf::FuturesInstrumentRequest_RequestType >(type_);
}
inline void FuturesInstrumentRequest::set_type(::kaqt::providers::protobuf::FuturesInstrumentRequest_RequestType value) {
  assert(::kaqt::providers::protobuf::FuturesInstrumentRequest_RequestType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrumentRequest.type)
}

// optional string underlying = 2;
inline bool FuturesInstrumentRequest::has_underlying() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FuturesInstrumentRequest::set_has_underlying() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FuturesInstrumentRequest::clear_has_underlying() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FuturesInstrumentRequest::clear_underlying() {
  if (underlying_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_->clear();
  }
  clear_has_underlying();
}
inline const ::std::string& FuturesInstrumentRequest::underlying() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrumentRequest.underlying)
  return *underlying_;
}
inline void FuturesInstrumentRequest::set_underlying(const ::std::string& value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrumentRequest.underlying)
}
inline void FuturesInstrumentRequest::set_underlying(const char* value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.FuturesInstrumentRequest.underlying)
}
inline void FuturesInstrumentRequest::set_underlying(const char* value, size_t size) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.FuturesInstrumentRequest.underlying)
}
inline ::std::string* FuturesInstrumentRequest::mutable_underlying() {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrumentRequest.underlying)
  return underlying_;
}
inline ::std::string* FuturesInstrumentRequest::release_underlying() {
  clear_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = underlying_;
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FuturesInstrumentRequest::set_allocated_underlying(::std::string* underlying) {
  if (underlying_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete underlying_;
  }
  if (underlying) {
    set_has_underlying();
    underlying_ = underlying;
  } else {
    clear_has_underlying();
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.FuturesInstrumentRequest.underlying)
}

// optional string exchange = 3;
inline bool FuturesInstrumentRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FuturesInstrumentRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FuturesInstrumentRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FuturesInstrumentRequest::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& FuturesInstrumentRequest::exchange() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrumentRequest.exchange)
  return *exchange_;
}
inline void FuturesInstrumentRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrumentRequest.exchange)
}
inline void FuturesInstrumentRequest::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.FuturesInstrumentRequest.exchange)
}
inline void FuturesInstrumentRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.FuturesInstrumentRequest.exchange)
}
inline ::std::string* FuturesInstrumentRequest::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrumentRequest.exchange)
  return exchange_;
}
inline ::std::string* FuturesInstrumentRequest::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FuturesInstrumentRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.FuturesInstrumentRequest.exchange)
}

// -------------------------------------------------------------------

// FuturesInstrumentResponse

// repeated .kaqt.providers.protobuf.FuturesInstrument instruments = 1;
inline int FuturesInstrumentResponse::instruments_size() const {
  return instruments_.size();
}
inline void FuturesInstrumentResponse::clear_instruments() {
  instruments_.Clear();
}
inline const ::kaqt::providers::protobuf::FuturesInstrument& FuturesInstrumentResponse::instruments(int index) const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrumentResponse.instruments)
  return instruments_.Get(index);
}
inline ::kaqt::providers::protobuf::FuturesInstrument* FuturesInstrumentResponse::mutable_instruments(int index) {
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrumentResponse.instruments)
  return instruments_.Mutable(index);
}
inline ::kaqt::providers::protobuf::FuturesInstrument* FuturesInstrumentResponse::add_instruments() {
  // @@protoc_insertion_point(field_add:kaqt.providers.protobuf.FuturesInstrumentResponse.instruments)
  return instruments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::FuturesInstrument >&
FuturesInstrumentResponse::instruments() const {
  // @@protoc_insertion_point(field_list:kaqt.providers.protobuf.FuturesInstrumentResponse.instruments)
  return instruments_;
}
inline ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::FuturesInstrument >*
FuturesInstrumentResponse::mutable_instruments() {
  // @@protoc_insertion_point(field_mutable_list:kaqt.providers.protobuf.FuturesInstrumentResponse.instruments)
  return &instruments_;
}

// -------------------------------------------------------------------

// FuturesInstrument

// required int32 id = 1;
inline bool FuturesInstrument::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FuturesInstrument::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FuturesInstrument::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FuturesInstrument::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 FuturesInstrument::id() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.id)
  return id_;
}
inline void FuturesInstrument::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.id)
}

// required string ticker = 2;
inline bool FuturesInstrument::has_ticker() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FuturesInstrument::set_has_ticker() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FuturesInstrument::clear_has_ticker() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FuturesInstrument::clear_ticker() {
  if (ticker_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_->clear();
  }
  clear_has_ticker();
}
inline const ::std::string& FuturesInstrument::ticker() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.ticker)
  return *ticker_;
}
inline void FuturesInstrument::set_ticker(const ::std::string& value) {
  set_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_ = new ::std::string;
  }
  ticker_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.ticker)
}
inline void FuturesInstrument::set_ticker(const char* value) {
  set_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_ = new ::std::string;
  }
  ticker_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.FuturesInstrument.ticker)
}
inline void FuturesInstrument::set_ticker(const char* value, size_t size) {
  set_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_ = new ::std::string;
  }
  ticker_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.FuturesInstrument.ticker)
}
inline ::std::string* FuturesInstrument::mutable_ticker() {
  set_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrument.ticker)
  return ticker_;
}
inline ::std::string* FuturesInstrument::release_ticker() {
  clear_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ticker_;
    ticker_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FuturesInstrument::set_allocated_ticker(::std::string* ticker) {
  if (ticker_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ticker_;
  }
  if (ticker) {
    set_has_ticker();
    ticker_ = ticker;
  } else {
    clear_has_ticker();
    ticker_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.FuturesInstrument.ticker)
}

// optional string underlying = 3;
inline bool FuturesInstrument::has_underlying() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FuturesInstrument::set_has_underlying() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FuturesInstrument::clear_has_underlying() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FuturesInstrument::clear_underlying() {
  if (underlying_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_->clear();
  }
  clear_has_underlying();
}
inline const ::std::string& FuturesInstrument::underlying() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.underlying)
  return *underlying_;
}
inline void FuturesInstrument::set_underlying(const ::std::string& value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.underlying)
}
inline void FuturesInstrument::set_underlying(const char* value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.FuturesInstrument.underlying)
}
inline void FuturesInstrument::set_underlying(const char* value, size_t size) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.FuturesInstrument.underlying)
}
inline ::std::string* FuturesInstrument::mutable_underlying() {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrument.underlying)
  return underlying_;
}
inline ::std::string* FuturesInstrument::release_underlying() {
  clear_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = underlying_;
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FuturesInstrument::set_allocated_underlying(::std::string* underlying) {
  if (underlying_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete underlying_;
  }
  if (underlying) {
    set_has_underlying();
    underlying_ = underlying;
  } else {
    clear_has_underlying();
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.FuturesInstrument.underlying)
}

// required string description = 4;
inline bool FuturesInstrument::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FuturesInstrument::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FuturesInstrument::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FuturesInstrument::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& FuturesInstrument::description() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.description)
  return *description_;
}
inline void FuturesInstrument::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.description)
}
inline void FuturesInstrument::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.FuturesInstrument.description)
}
inline void FuturesInstrument::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.FuturesInstrument.description)
}
inline ::std::string* FuturesInstrument::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrument.description)
  return description_;
}
inline ::std::string* FuturesInstrument::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FuturesInstrument::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.FuturesInstrument.description)
}

// required string exchange_group = 5;
inline bool FuturesInstrument::has_exchange_group() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FuturesInstrument::set_has_exchange_group() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FuturesInstrument::clear_has_exchange_group() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FuturesInstrument::clear_exchange_group() {
  if (exchange_group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_->clear();
  }
  clear_has_exchange_group();
}
inline const ::std::string& FuturesInstrument::exchange_group() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.exchange_group)
  return *exchange_group_;
}
inline void FuturesInstrument::set_exchange_group(const ::std::string& value) {
  set_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_ = new ::std::string;
  }
  exchange_group_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.exchange_group)
}
inline void FuturesInstrument::set_exchange_group(const char* value) {
  set_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_ = new ::std::string;
  }
  exchange_group_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.FuturesInstrument.exchange_group)
}
inline void FuturesInstrument::set_exchange_group(const char* value, size_t size) {
  set_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_ = new ::std::string;
  }
  exchange_group_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.FuturesInstrument.exchange_group)
}
inline ::std::string* FuturesInstrument::mutable_exchange_group() {
  set_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrument.exchange_group)
  return exchange_group_;
}
inline ::std::string* FuturesInstrument::release_exchange_group() {
  clear_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_group_;
    exchange_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FuturesInstrument::set_allocated_exchange_group(::std::string* exchange_group) {
  if (exchange_group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_group_;
  }
  if (exchange_group) {
    set_has_exchange_group();
    exchange_group_ = exchange_group;
  } else {
    clear_has_exchange_group();
    exchange_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.FuturesInstrument.exchange_group)
}

// required string exchange = 6;
inline bool FuturesInstrument::has_exchange() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FuturesInstrument::set_has_exchange() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FuturesInstrument::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FuturesInstrument::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& FuturesInstrument::exchange() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.exchange)
  return *exchange_;
}
inline void FuturesInstrument::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.exchange)
}
inline void FuturesInstrument::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.FuturesInstrument.exchange)
}
inline void FuturesInstrument::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.FuturesInstrument.exchange)
}
inline ::std::string* FuturesInstrument::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrument.exchange)
  return exchange_;
}
inline ::std::string* FuturesInstrument::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FuturesInstrument::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.FuturesInstrument.exchange)
}

// required int64 expiry_posix_datetime = 7;
inline bool FuturesInstrument::has_expiry_posix_datetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FuturesInstrument::set_has_expiry_posix_datetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FuturesInstrument::clear_has_expiry_posix_datetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FuturesInstrument::clear_expiry_posix_datetime() {
  expiry_posix_datetime_ = GOOGLE_LONGLONG(0);
  clear_has_expiry_posix_datetime();
}
inline ::google::protobuf::int64 FuturesInstrument::expiry_posix_datetime() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.expiry_posix_datetime)
  return expiry_posix_datetime_;
}
inline void FuturesInstrument::set_expiry_posix_datetime(::google::protobuf::int64 value) {
  set_has_expiry_posix_datetime();
  expiry_posix_datetime_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.expiry_posix_datetime)
}

// required int32 min_order_size = 8;
inline bool FuturesInstrument::has_min_order_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FuturesInstrument::set_has_min_order_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FuturesInstrument::clear_has_min_order_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FuturesInstrument::clear_min_order_size() {
  min_order_size_ = 0;
  clear_has_min_order_size();
}
inline ::google::protobuf::int32 FuturesInstrument::min_order_size() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.min_order_size)
  return min_order_size_;
}
inline void FuturesInstrument::set_min_order_size(::google::protobuf::int32 value) {
  set_has_min_order_size();
  min_order_size_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.min_order_size)
}

// required double tick_size = 9;
inline bool FuturesInstrument::has_tick_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FuturesInstrument::set_has_tick_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FuturesInstrument::clear_has_tick_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FuturesInstrument::clear_tick_size() {
  tick_size_ = 0;
  clear_has_tick_size();
}
inline double FuturesInstrument::tick_size() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.tick_size)
  return tick_size_;
}
inline void FuturesInstrument::set_tick_size(double value) {
  set_has_tick_size();
  tick_size_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.tick_size)
}

// required double tradeable_tick_size = 10;
inline bool FuturesInstrument::has_tradeable_tick_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FuturesInstrument::set_has_tradeable_tick_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FuturesInstrument::clear_has_tradeable_tick_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FuturesInstrument::clear_tradeable_tick_size() {
  tradeable_tick_size_ = 0;
  clear_has_tradeable_tick_size();
}
inline double FuturesInstrument::tradeable_tick_size() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.tradeable_tick_size)
  return tradeable_tick_size_;
}
inline void FuturesInstrument::set_tradeable_tick_size(double value) {
  set_has_tradeable_tick_size();
  tradeable_tick_size_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.tradeable_tick_size)
}

// required string currency = 11;
inline bool FuturesInstrument::has_currency() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FuturesInstrument::set_has_currency() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FuturesInstrument::clear_has_currency() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FuturesInstrument::clear_currency() {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& FuturesInstrument::currency() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.currency)
  return *currency_;
}
inline void FuturesInstrument::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.currency)
}
inline void FuturesInstrument::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.FuturesInstrument.currency)
}
inline void FuturesInstrument::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.FuturesInstrument.currency)
}
inline ::std::string* FuturesInstrument::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrument.currency)
  return currency_;
}
inline ::std::string* FuturesInstrument::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FuturesInstrument::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.FuturesInstrument.currency)
}

// repeated .kaqt.providers.protobuf.AlternateId alternate_id = 12;
inline int FuturesInstrument::alternate_id_size() const {
  return alternate_id_.size();
}
inline void FuturesInstrument::clear_alternate_id() {
  alternate_id_.Clear();
}
inline const ::kaqt::providers::protobuf::AlternateId& FuturesInstrument::alternate_id(int index) const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.alternate_id)
  return alternate_id_.Get(index);
}
inline ::kaqt::providers::protobuf::AlternateId* FuturesInstrument::mutable_alternate_id(int index) {
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FuturesInstrument.alternate_id)
  return alternate_id_.Mutable(index);
}
inline ::kaqt::providers::protobuf::AlternateId* FuturesInstrument::add_alternate_id() {
  // @@protoc_insertion_point(field_add:kaqt.providers.protobuf.FuturesInstrument.alternate_id)
  return alternate_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId >&
FuturesInstrument::alternate_id() const {
  // @@protoc_insertion_point(field_list:kaqt.providers.protobuf.FuturesInstrument.alternate_id)
  return alternate_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId >*
FuturesInstrument::mutable_alternate_id() {
  // @@protoc_insertion_point(field_mutable_list:kaqt.providers.protobuf.FuturesInstrument.alternate_id)
  return &alternate_id_;
}

// repeated int32 constituents_ids = 13;
inline int FuturesInstrument::constituents_ids_size() const {
  return constituents_ids_.size();
}
inline void FuturesInstrument::clear_constituents_ids() {
  constituents_ids_.Clear();
}
inline ::google::protobuf::int32 FuturesInstrument::constituents_ids(int index) const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.constituents_ids)
  return constituents_ids_.Get(index);
}
inline void FuturesInstrument::set_constituents_ids(int index, ::google::protobuf::int32 value) {
  constituents_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.constituents_ids)
}
inline void FuturesInstrument::add_constituents_ids(::google::protobuf::int32 value) {
  constituents_ids_.Add(value);
  // @@protoc_insertion_point(field_add:kaqt.providers.protobuf.FuturesInstrument.constituents_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FuturesInstrument::constituents_ids() const {
  // @@protoc_insertion_point(field_list:kaqt.providers.protobuf.FuturesInstrument.constituents_ids)
  return constituents_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FuturesInstrument::mutable_constituents_ids() {
  // @@protoc_insertion_point(field_mutable_list:kaqt.providers.protobuf.FuturesInstrument.constituents_ids)
  return &constituents_ids_;
}

// repeated int32 constituents_ratios = 14;
inline int FuturesInstrument::constituents_ratios_size() const {
  return constituents_ratios_.size();
}
inline void FuturesInstrument::clear_constituents_ratios() {
  constituents_ratios_.Clear();
}
inline ::google::protobuf::int32 FuturesInstrument::constituents_ratios(int index) const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FuturesInstrument.constituents_ratios)
  return constituents_ratios_.Get(index);
}
inline void FuturesInstrument::set_constituents_ratios(int index, ::google::protobuf::int32 value) {
  constituents_ratios_.Set(index, value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FuturesInstrument.constituents_ratios)
}
inline void FuturesInstrument::add_constituents_ratios(::google::protobuf::int32 value) {
  constituents_ratios_.Add(value);
  // @@protoc_insertion_point(field_add:kaqt.providers.protobuf.FuturesInstrument.constituents_ratios)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FuturesInstrument::constituents_ratios() const {
  // @@protoc_insertion_point(field_list:kaqt.providers.protobuf.FuturesInstrument.constituents_ratios)
  return constituents_ratios_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FuturesInstrument::mutable_constituents_ratios() {
  // @@protoc_insertion_point(field_mutable_list:kaqt.providers.protobuf.FuturesInstrument.constituents_ratios)
  return &constituents_ratios_;
}

// -------------------------------------------------------------------

// AlternateId

// required string id_type = 1;
inline bool AlternateId::has_id_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlternateId::set_has_id_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlternateId::clear_has_id_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlternateId::clear_id_type() {
  if (id_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_type_->clear();
  }
  clear_has_id_type();
}
inline const ::std::string& AlternateId::id_type() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.AlternateId.id_type)
  return *id_type_;
}
inline void AlternateId::set_id_type(const ::std::string& value) {
  set_has_id_type();
  if (id_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_type_ = new ::std::string;
  }
  id_type_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.AlternateId.id_type)
}
inline void AlternateId::set_id_type(const char* value) {
  set_has_id_type();
  if (id_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_type_ = new ::std::string;
  }
  id_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.AlternateId.id_type)
}
inline void AlternateId::set_id_type(const char* value, size_t size) {
  set_has_id_type();
  if (id_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_type_ = new ::std::string;
  }
  id_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.AlternateId.id_type)
}
inline ::std::string* AlternateId::mutable_id_type() {
  set_has_id_type();
  if (id_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.AlternateId.id_type)
  return id_type_;
}
inline ::std::string* AlternateId::release_id_type() {
  clear_has_id_type();
  if (id_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_type_;
    id_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AlternateId::set_allocated_id_type(::std::string* id_type) {
  if (id_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_type_;
  }
  if (id_type) {
    set_has_id_type();
    id_type_ = id_type;
  } else {
    clear_has_id_type();
    id_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.AlternateId.id_type)
}

// required string id = 2;
inline bool AlternateId::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlternateId::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlternateId::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlternateId::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AlternateId::id() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.AlternateId.id)
  return *id_;
}
inline void AlternateId::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.AlternateId.id)
}
inline void AlternateId::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.AlternateId.id)
}
inline void AlternateId::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.AlternateId.id)
}
inline ::std::string* AlternateId::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.AlternateId.id)
  return id_;
}
inline ::std::string* AlternateId::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AlternateId::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.AlternateId.id)
}

// optional string description = 3;
inline bool AlternateId::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AlternateId::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AlternateId::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AlternateId::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& AlternateId::description() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.AlternateId.description)
  return *description_;
}
inline void AlternateId::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.AlternateId.description)
}
inline void AlternateId::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.AlternateId.description)
}
inline void AlternateId::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.AlternateId.description)
}
inline ::std::string* AlternateId::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.AlternateId.description)
  return description_;
}
inline ::std::string* AlternateId::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AlternateId::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.AlternateId.description)
}

// -------------------------------------------------------------------

// Instrument

// required int32 id = 1;
inline bool Instrument::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Instrument::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Instrument::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Instrument::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Instrument::id() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.id)
  return id_;
}
inline void Instrument::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.id)
}

// required .kaqt.providers.protobuf.Instrument.InstrumentType type = 2;
inline bool Instrument::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Instrument::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Instrument::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Instrument::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::kaqt::providers::protobuf::Instrument_InstrumentType Instrument::type() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.type)
  return static_cast< ::kaqt::providers::protobuf::Instrument_InstrumentType >(type_);
}
inline void Instrument::set_type(::kaqt::providers::protobuf::Instrument_InstrumentType value) {
  assert(::kaqt::providers::protobuf::Instrument_InstrumentType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.type)
}

// required string ticker = 3;
inline bool Instrument::has_ticker() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Instrument::set_has_ticker() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Instrument::clear_has_ticker() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Instrument::clear_ticker() {
  if (ticker_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_->clear();
  }
  clear_has_ticker();
}
inline const ::std::string& Instrument::ticker() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.ticker)
  return *ticker_;
}
inline void Instrument::set_ticker(const ::std::string& value) {
  set_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_ = new ::std::string;
  }
  ticker_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.ticker)
}
inline void Instrument::set_ticker(const char* value) {
  set_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_ = new ::std::string;
  }
  ticker_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.Instrument.ticker)
}
inline void Instrument::set_ticker(const char* value, size_t size) {
  set_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_ = new ::std::string;
  }
  ticker_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.Instrument.ticker)
}
inline ::std::string* Instrument::mutable_ticker() {
  set_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.Instrument.ticker)
  return ticker_;
}
inline ::std::string* Instrument::release_ticker() {
  clear_has_ticker();
  if (ticker_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ticker_;
    ticker_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Instrument::set_allocated_ticker(::std::string* ticker) {
  if (ticker_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ticker_;
  }
  if (ticker) {
    set_has_ticker();
    ticker_ = ticker;
  } else {
    clear_has_ticker();
    ticker_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.Instrument.ticker)
}

// required string description = 4;
inline bool Instrument::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Instrument::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Instrument::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Instrument::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Instrument::description() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.description)
  return *description_;
}
inline void Instrument::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.description)
}
inline void Instrument::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.Instrument.description)
}
inline void Instrument::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.Instrument.description)
}
inline ::std::string* Instrument::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.Instrument.description)
  return description_;
}
inline ::std::string* Instrument::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Instrument::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.Instrument.description)
}

// required string exchange = 5;
inline bool Instrument::has_exchange() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Instrument::set_has_exchange() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Instrument::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Instrument::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& Instrument::exchange() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.exchange)
  return *exchange_;
}
inline void Instrument::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.exchange)
}
inline void Instrument::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.Instrument.exchange)
}
inline void Instrument::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.Instrument.exchange)
}
inline ::std::string* Instrument::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.Instrument.exchange)
  return exchange_;
}
inline ::std::string* Instrument::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Instrument::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.Instrument.exchange)
}

// optional string exchange_group = 6;
inline bool Instrument::has_exchange_group() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Instrument::set_has_exchange_group() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Instrument::clear_has_exchange_group() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Instrument::clear_exchange_group() {
  if (exchange_group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_->clear();
  }
  clear_has_exchange_group();
}
inline const ::std::string& Instrument::exchange_group() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.exchange_group)
  return *exchange_group_;
}
inline void Instrument::set_exchange_group(const ::std::string& value) {
  set_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_ = new ::std::string;
  }
  exchange_group_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.exchange_group)
}
inline void Instrument::set_exchange_group(const char* value) {
  set_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_ = new ::std::string;
  }
  exchange_group_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.Instrument.exchange_group)
}
inline void Instrument::set_exchange_group(const char* value, size_t size) {
  set_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_ = new ::std::string;
  }
  exchange_group_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.Instrument.exchange_group)
}
inline ::std::string* Instrument::mutable_exchange_group() {
  set_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_group_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.Instrument.exchange_group)
  return exchange_group_;
}
inline ::std::string* Instrument::release_exchange_group() {
  clear_has_exchange_group();
  if (exchange_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_group_;
    exchange_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Instrument::set_allocated_exchange_group(::std::string* exchange_group) {
  if (exchange_group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_group_;
  }
  if (exchange_group) {
    set_has_exchange_group();
    exchange_group_ = exchange_group;
  } else {
    clear_has_exchange_group();
    exchange_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.Instrument.exchange_group)
}

// required int32 min_order_size = 7;
inline bool Instrument::has_min_order_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Instrument::set_has_min_order_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Instrument::clear_has_min_order_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Instrument::clear_min_order_size() {
  min_order_size_ = 0;
  clear_has_min_order_size();
}
inline ::google::protobuf::int32 Instrument::min_order_size() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.min_order_size)
  return min_order_size_;
}
inline void Instrument::set_min_order_size(::google::protobuf::int32 value) {
  set_has_min_order_size();
  min_order_size_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.min_order_size)
}

// required double tick_size = 8;
inline bool Instrument::has_tick_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Instrument::set_has_tick_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Instrument::clear_has_tick_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Instrument::clear_tick_size() {
  tick_size_ = 0;
  clear_has_tick_size();
}
inline double Instrument::tick_size() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.tick_size)
  return tick_size_;
}
inline void Instrument::set_tick_size(double value) {
  set_has_tick_size();
  tick_size_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.tick_size)
}

// required double tradeable_tick_size = 9;
inline bool Instrument::has_tradeable_tick_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Instrument::set_has_tradeable_tick_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Instrument::clear_has_tradeable_tick_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Instrument::clear_tradeable_tick_size() {
  tradeable_tick_size_ = 0;
  clear_has_tradeable_tick_size();
}
inline double Instrument::tradeable_tick_size() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.tradeable_tick_size)
  return tradeable_tick_size_;
}
inline void Instrument::set_tradeable_tick_size(double value) {
  set_has_tradeable_tick_size();
  tradeable_tick_size_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.tradeable_tick_size)
}

// required string currency = 10;
inline bool Instrument::has_currency() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Instrument::set_has_currency() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Instrument::clear_has_currency() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Instrument::clear_currency() {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& Instrument::currency() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.currency)
  return *currency_;
}
inline void Instrument::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.Instrument.currency)
}
inline void Instrument::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.Instrument.currency)
}
inline void Instrument::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.Instrument.currency)
}
inline ::std::string* Instrument::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.Instrument.currency)
  return currency_;
}
inline ::std::string* Instrument::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Instrument::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.Instrument.currency)
}

// repeated .kaqt.providers.protobuf.AlternateId alternate_id = 11;
inline int Instrument::alternate_id_size() const {
  return alternate_id_.size();
}
inline void Instrument::clear_alternate_id() {
  alternate_id_.Clear();
}
inline const ::kaqt::providers::protobuf::AlternateId& Instrument::alternate_id(int index) const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.alternate_id)
  return alternate_id_.Get(index);
}
inline ::kaqt::providers::protobuf::AlternateId* Instrument::mutable_alternate_id(int index) {
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.Instrument.alternate_id)
  return alternate_id_.Mutable(index);
}
inline ::kaqt::providers::protobuf::AlternateId* Instrument::add_alternate_id() {
  // @@protoc_insertion_point(field_add:kaqt.providers.protobuf.Instrument.alternate_id)
  return alternate_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId >&
Instrument::alternate_id() const {
  // @@protoc_insertion_point(field_list:kaqt.providers.protobuf.Instrument.alternate_id)
  return alternate_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::kaqt::providers::protobuf::AlternateId >*
Instrument::mutable_alternate_id() {
  // @@protoc_insertion_point(field_mutable_list:kaqt.providers.protobuf.Instrument.alternate_id)
  return &alternate_id_;
}

// optional .kaqt.providers.protobuf.FutureSpecification futures_spec = 12;
inline bool Instrument::has_futures_spec() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Instrument::set_has_futures_spec() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Instrument::clear_has_futures_spec() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Instrument::clear_futures_spec() {
  if (futures_spec_ != NULL) futures_spec_->::kaqt::providers::protobuf::FutureSpecification::Clear();
  clear_has_futures_spec();
}
inline const ::kaqt::providers::protobuf::FutureSpecification& Instrument::futures_spec() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.futures_spec)
  return futures_spec_ != NULL ? *futures_spec_ : *default_instance_->futures_spec_;
}
inline ::kaqt::providers::protobuf::FutureSpecification* Instrument::mutable_futures_spec() {
  set_has_futures_spec();
  if (futures_spec_ == NULL) futures_spec_ = new ::kaqt::providers::protobuf::FutureSpecification;
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.Instrument.futures_spec)
  return futures_spec_;
}
inline ::kaqt::providers::protobuf::FutureSpecification* Instrument::release_futures_spec() {
  clear_has_futures_spec();
  ::kaqt::providers::protobuf::FutureSpecification* temp = futures_spec_;
  futures_spec_ = NULL;
  return temp;
}
inline void Instrument::set_allocated_futures_spec(::kaqt::providers::protobuf::FutureSpecification* futures_spec) {
  delete futures_spec_;
  futures_spec_ = futures_spec;
  if (futures_spec) {
    set_has_futures_spec();
  } else {
    clear_has_futures_spec();
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.Instrument.futures_spec)
}

// optional .kaqt.providers.protobuf.OptionSpecification options_spec = 13;
inline bool Instrument::has_options_spec() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Instrument::set_has_options_spec() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Instrument::clear_has_options_spec() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Instrument::clear_options_spec() {
  if (options_spec_ != NULL) options_spec_->::kaqt::providers::protobuf::OptionSpecification::Clear();
  clear_has_options_spec();
}
inline const ::kaqt::providers::protobuf::OptionSpecification& Instrument::options_spec() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.Instrument.options_spec)
  return options_spec_ != NULL ? *options_spec_ : *default_instance_->options_spec_;
}
inline ::kaqt::providers::protobuf::OptionSpecification* Instrument::mutable_options_spec() {
  set_has_options_spec();
  if (options_spec_ == NULL) options_spec_ = new ::kaqt::providers::protobuf::OptionSpecification;
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.Instrument.options_spec)
  return options_spec_;
}
inline ::kaqt::providers::protobuf::OptionSpecification* Instrument::release_options_spec() {
  clear_has_options_spec();
  ::kaqt::providers::protobuf::OptionSpecification* temp = options_spec_;
  options_spec_ = NULL;
  return temp;
}
inline void Instrument::set_allocated_options_spec(::kaqt::providers::protobuf::OptionSpecification* options_spec) {
  delete options_spec_;
  options_spec_ = options_spec;
  if (options_spec) {
    set_has_options_spec();
  } else {
    clear_has_options_spec();
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.Instrument.options_spec)
}

// -------------------------------------------------------------------

// FutureSpecification

// required int64 expiry_posix_datetime = 1;
inline bool FutureSpecification::has_expiry_posix_datetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FutureSpecification::set_has_expiry_posix_datetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FutureSpecification::clear_has_expiry_posix_datetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FutureSpecification::clear_expiry_posix_datetime() {
  expiry_posix_datetime_ = GOOGLE_LONGLONG(0);
  clear_has_expiry_posix_datetime();
}
inline ::google::protobuf::int64 FutureSpecification::expiry_posix_datetime() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FutureSpecification.expiry_posix_datetime)
  return expiry_posix_datetime_;
}
inline void FutureSpecification::set_expiry_posix_datetime(::google::protobuf::int64 value) {
  set_has_expiry_posix_datetime();
  expiry_posix_datetime_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FutureSpecification.expiry_posix_datetime)
}

// required string underlying = 2;
inline bool FutureSpecification::has_underlying() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FutureSpecification::set_has_underlying() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FutureSpecification::clear_has_underlying() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FutureSpecification::clear_underlying() {
  if (underlying_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_->clear();
  }
  clear_has_underlying();
}
inline const ::std::string& FutureSpecification::underlying() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.FutureSpecification.underlying)
  return *underlying_;
}
inline void FutureSpecification::set_underlying(const ::std::string& value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.FutureSpecification.underlying)
}
inline void FutureSpecification::set_underlying(const char* value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.FutureSpecification.underlying)
}
inline void FutureSpecification::set_underlying(const char* value, size_t size) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.FutureSpecification.underlying)
}
inline ::std::string* FutureSpecification::mutable_underlying() {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.FutureSpecification.underlying)
  return underlying_;
}
inline ::std::string* FutureSpecification::release_underlying() {
  clear_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = underlying_;
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FutureSpecification::set_allocated_underlying(::std::string* underlying) {
  if (underlying_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete underlying_;
  }
  if (underlying) {
    set_has_underlying();
    underlying_ = underlying;
  } else {
    clear_has_underlying();
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.FutureSpecification.underlying)
}

// -------------------------------------------------------------------

// OptionSpecification

// required double strike = 1;
inline bool OptionSpecification::has_strike() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OptionSpecification::set_has_strike() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OptionSpecification::clear_has_strike() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OptionSpecification::clear_strike() {
  strike_ = 0;
  clear_has_strike();
}
inline double OptionSpecification::strike() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.OptionSpecification.strike)
  return strike_;
}
inline void OptionSpecification::set_strike(double value) {
  set_has_strike();
  strike_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.OptionSpecification.strike)
}

// required int64 expiry_posix_datetime = 2;
inline bool OptionSpecification::has_expiry_posix_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OptionSpecification::set_has_expiry_posix_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OptionSpecification::clear_has_expiry_posix_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OptionSpecification::clear_expiry_posix_datetime() {
  expiry_posix_datetime_ = GOOGLE_LONGLONG(0);
  clear_has_expiry_posix_datetime();
}
inline ::google::protobuf::int64 OptionSpecification::expiry_posix_datetime() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.OptionSpecification.expiry_posix_datetime)
  return expiry_posix_datetime_;
}
inline void OptionSpecification::set_expiry_posix_datetime(::google::protobuf::int64 value) {
  set_has_expiry_posix_datetime();
  expiry_posix_datetime_ = value;
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.OptionSpecification.expiry_posix_datetime)
}

// required string underlying = 3;
inline bool OptionSpecification::has_underlying() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OptionSpecification::set_has_underlying() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OptionSpecification::clear_has_underlying() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OptionSpecification::clear_underlying() {
  if (underlying_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_->clear();
  }
  clear_has_underlying();
}
inline const ::std::string& OptionSpecification::underlying() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.OptionSpecification.underlying)
  return *underlying_;
}
inline void OptionSpecification::set_underlying(const ::std::string& value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.OptionSpecification.underlying)
}
inline void OptionSpecification::set_underlying(const char* value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.OptionSpecification.underlying)
}
inline void OptionSpecification::set_underlying(const char* value, size_t size) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.OptionSpecification.underlying)
}
inline ::std::string* OptionSpecification::mutable_underlying() {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlying_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.OptionSpecification.underlying)
  return underlying_;
}
inline ::std::string* OptionSpecification::release_underlying() {
  clear_has_underlying();
  if (underlying_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = underlying_;
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OptionSpecification::set_allocated_underlying(::std::string* underlying) {
  if (underlying_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete underlying_;
  }
  if (underlying) {
    set_has_underlying();
    underlying_ = underlying;
  } else {
    clear_has_underlying();
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.OptionSpecification.underlying)
}

// -------------------------------------------------------------------

// ForexSpecification

// required string counter_currency = 1;
inline bool ForexSpecification::has_counter_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForexSpecification::set_has_counter_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForexSpecification::clear_has_counter_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForexSpecification::clear_counter_currency() {
  if (counter_currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counter_currency_->clear();
  }
  clear_has_counter_currency();
}
inline const ::std::string& ForexSpecification::counter_currency() const {
  // @@protoc_insertion_point(field_get:kaqt.providers.protobuf.ForexSpecification.counter_currency)
  return *counter_currency_;
}
inline void ForexSpecification::set_counter_currency(const ::std::string& value) {
  set_has_counter_currency();
  if (counter_currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counter_currency_ = new ::std::string;
  }
  counter_currency_->assign(value);
  // @@protoc_insertion_point(field_set:kaqt.providers.protobuf.ForexSpecification.counter_currency)
}
inline void ForexSpecification::set_counter_currency(const char* value) {
  set_has_counter_currency();
  if (counter_currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counter_currency_ = new ::std::string;
  }
  counter_currency_->assign(value);
  // @@protoc_insertion_point(field_set_char:kaqt.providers.protobuf.ForexSpecification.counter_currency)
}
inline void ForexSpecification::set_counter_currency(const char* value, size_t size) {
  set_has_counter_currency();
  if (counter_currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counter_currency_ = new ::std::string;
  }
  counter_currency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaqt.providers.protobuf.ForexSpecification.counter_currency)
}
inline ::std::string* ForexSpecification::mutable_counter_currency() {
  set_has_counter_currency();
  if (counter_currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counter_currency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kaqt.providers.protobuf.ForexSpecification.counter_currency)
  return counter_currency_;
}
inline ::std::string* ForexSpecification::release_counter_currency() {
  clear_has_counter_currency();
  if (counter_currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = counter_currency_;
    counter_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ForexSpecification::set_allocated_counter_currency(::std::string* counter_currency) {
  if (counter_currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete counter_currency_;
  }
  if (counter_currency) {
    set_has_counter_currency();
    counter_currency_ = counter_currency;
  } else {
    clear_has_counter_currency();
    counter_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kaqt.providers.protobuf.ForexSpecification.counter_currency)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace providers
}  // namespace kaqt

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::kaqt::providers::protobuf::FuturesInstrumentRequest_RequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kaqt::providers::protobuf::FuturesInstrumentRequest_RequestType>() {
  return ::kaqt::providers::protobuf::FuturesInstrumentRequest_RequestType_descriptor();
}
template <> struct is_proto_enum< ::kaqt::providers::protobuf::Instrument_InstrumentType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kaqt::providers::protobuf::Instrument_InstrumentType>() {
  return ::kaqt::providers::protobuf::Instrument_InstrumentType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_symbology_2eproto__INCLUDED
